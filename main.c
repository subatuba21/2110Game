#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/pacman.h"
#include "images/pacman-sprite.h"
#include "images/pacmanstartclosed.h"
#include "images/pacmanstart.h"
#include "images/ghost.h"
#include "images/dot.h"
#include "images/trophy.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state
{
  START,
  START1,
  PLAY,
  WIN,
  WIN1,
  LOSE,
  LOSE1
};

int startScreenAnimation = 0;
int pacManIsClosed = 0;
int currentLevel = 5;

int currentSpriteX = 0;
int currentSpriteY = 0;
int oldSpriteX = 0;
int oldSpriteY = 0;
int numSprites = 50;
int numBalls = 10;
int timeLeft = 60;

struct spritepos sprites[100];
struct ball balls[100];

int main(void)
{
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  while (1)
  {
    int time = timeLeft - vBlankCounter / 60;
    char timeStr[15];
    sprintf(timeStr, "00:%d", time);
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    if (KEY_DOWN(BUTTON_SELECT, currentButtons))
    {
      state = START;
      startScreenAnimation = 0;
      pacManIsClosed = 0;
      currentLevel = 5;

      currentSpriteX = 0;
      currentSpriteY = 0;
      oldSpriteX = 0;
      oldSpriteY = 0;
      numSprites = 50;
      numBalls = 10;
      timeLeft = 60;
    }
    switch (state)
    {
    case START:
      drawImageDMA(0, 0, PACMAN_WIDTH, PACMAN_HEIGHT, pacman);
      char *str = "PACMAN BUT EASIER";
      char *play = "PRESS ENTER TO PLAY.";
      drawString(110, 10, str, YELLOW);
      drawString(130, 10, play, RED);
      drawRectDMA(120, 10, 240, 10, BLACK);
      char levelStr1[80];
      sprintf(levelStr1, "LEVEL: %d. VERT ARROW KEYS TO CHANGE.", currentLevel);
      drawString(120, 10, levelStr1, GREEN);
      state = START1;
      break;
    case START1:
      drawRectDMA(0, startScreenAnimation - 1, PACMANSTART_WIDTH, PACMANSTART_HEIGHT + 5, BLACK);
      char levelStr[80];
      sprintf(levelStr, "LEVEL: %d. VERT ARROW KEYS TO CHANGE.", currentLevel);
      if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons))
      {
        if (currentLevel < 10)
        {
          currentLevel++;
          sprintf(levelStr, "LEVEL: %d. VERT ARROW KEYS TO CHANGE.", currentLevel);
          drawRectDMA(120, 10, 240, 10, BLACK);
          drawString(120, 10, levelStr, GREEN);
        }
      }
      else if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons))
      {
        if (currentLevel > 0)
        {
          currentLevel--;
          sprintf(levelStr, "LEVEL: %d. VERT ARROW KEYS TO CHANGE.", currentLevel);
          drawRectDMA(120, 10, 240, 10, BLACK);
          drawString(120, 10, levelStr, GREEN);
        }
      }
      if (startScreenAnimation % 10 == 0)
      {
        pacManIsClosed++;
        pacManIsClosed %= 2;
      }

      if (pacManIsClosed)
      {
        drawImageDMA(0, startScreenAnimation, PACMANSTART_WIDTH, PACMANSTART_HEIGHT, pacmanstart);
      }
      else
      {
        drawImageDMA(0, startScreenAnimation, PACMANSTART_WIDTH, PACMANSTART_HEIGHT, pacmanstartclosed);
      }
      startScreenAnimation++;
      startScreenAnimation %= 240;

      if (KEY_DOWN(BUTTON_START, currentButtons))
      {
        numSprites = 2 + currentLevel * 8;
        numBalls = 3 + currentLevel * 1;
        state = PLAY;
        vBlankCounter = 0;
        for (int i = 0; i < numSprites; i++)
        {
          struct spritepos s;
          s.x = randint(30, 210);
          s.y = randint(30, 130);
          sprites[i] = s;
        }

        randint(30, 210);
        randint(30, 210);

        int i = 0;
        while (i < numBalls)
        {
          struct ball b;
          b.x = randint(30, 210);
          b.y = randint(30, 130);
          b.eaten = 0;
          b.justEaten = 0;
          int overlapping = 0;
          for (int x = 0; x < numSprites; x++)
          {
            if (abs(b.x - sprites[x].x) < 15 && abs(b.y - sprites[x].y) < 15)
            {
              overlapping = 1;
              break;
            }
          }
          if (overlapping)
          {
            continue;
          }
          else
          {
            balls[i] = b;
            i++;
          }
        }

        fillScreenDMA(BLACK);

        for (int i = 0; i < numSprites; i++)
        {
          struct spritepos s = sprites[i];
          drawImageDMA(s.y, s.x, GHOST_WIDTH, GHOST_HEIGHT, ghost);
        }

        for (int i = 0; i < numBalls; i++)
        {
          struct ball b = balls[i];
          if (b.eaten == 0)
          {
            drawImageDMA(b.y, b.x, DOT_WIDTH, DOT_HEIGHT, dot);
          }
        }
      }
      break;
    case PLAY:
      drawRectDMA(oldSpriteY, oldSpriteX, PACMANSPRITE_WIDTH, PACMANSPRITE_HEIGHT, BLACK);
      drawRectDMA(0, 170, 100, 10, BLACK);
      drawString(0, 170, timeStr, RED);
      drawImageDMA(currentSpriteY, currentSpriteX, PACMANSPRITE_WIDTH, PACMANSPRITE_HEIGHT, pacmansprite);
      for (int i = 0; i < numBalls; i++)
      {
        struct ball b = balls[i];
        if (b.justEaten == 1)
        {
          drawRectDMA(b.y, b.x, DOT_WIDTH, DOT_HEIGHT, BLACK);
          drawImageDMA(currentSpriteY, currentSpriteX, PACMANSPRITE_WIDTH, PACMANSPRITE_HEIGHT, pacmansprite);
          balls[i].justEaten = 0;
        }
      }
      oldSpriteX = currentSpriteX;
      oldSpriteY = currentSpriteY;
      if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && currentSpriteX < 225)
      {
        currentSpriteX++;
      }
      if (KEY_DOWN(BUTTON_DOWN, currentButtons) && currentSpriteY < 145)
      {
        currentSpriteY++;
      }
      if (KEY_DOWN(BUTTON_LEFT, currentButtons) && currentSpriteX > 0)
      {
        currentSpriteX--;
      }
      if (KEY_DOWN(BUTTON_UP, currentButtons) && currentSpriteY > 0)
      {
        currentSpriteY--;
      }

      for (int i = 0; i < numSprites; i++)
      {
        struct spritepos s = sprites[i];
        if (abs(s.x - currentSpriteX) < 15 && abs(s.y - currentSpriteY) < 15)
        {
          state = LOSE;
        }
      }

      int numEaten = 0;
      for (int i = 0; i < numBalls; i++)
      {
        struct ball b = balls[i];
        if (b.eaten)
        {
          numEaten++;
        }
        if (abs(b.x - currentSpriteX) < 15 && abs(b.y - currentSpriteY) < 15)
        {
          balls[i].eaten = 1;
          balls[i].justEaten = 1;
        }
      }
      if (time <= 0)
      {
        state = LOSE;
      }
      if (numEaten == numBalls)
      {
        state = WIN;
      }
      break;
    case WIN:
      drawImageDMA(0, 0, TROPHY_WIDTH, TROPHY_HEIGHT, trophy);
      char *won = "YOU WON! PRESS SELECT TO PLAY AGAIN!";
      drawString(50, 10, won, GREEN);
      state = WIN1;
      break;
    case WIN1:
      break;
    case LOSE:
      fillScreenDMA(RED);
      char *lost1 = "YOU LOST! SUCH AN L.";
      char *lost2 = "PRESS SELECT TO PLAY AGAIN.";
      drawString(50, 10, lost1, BLACK);
      drawString(100, 10, lost2, BLACK);
      state = WIN1;
      break;
    case LOSE1:
      break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
